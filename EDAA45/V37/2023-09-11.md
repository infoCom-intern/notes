# EDAA45

## Funktioner och abstraktion, 2023-09-11

### Abstraktion

- Abstraktion innebr att skapa en förenklad modell ur konkreta detaljer
- Vi hittar på nya begrepp som ger oss återanvändbara byggblock för våra tankar och vår kommunikation

### Exempel på abstraktionsmekanismen inom datavenskapen

Vi kommer att behandla flera olika, alltmer kraftfulla abstraktionsmekanisker i denna kurs:

- Funktioner
- Objekt
- Klasser
- Arv
- Generiska strukturer
- Kontextuella abstraktioner

Dessa abstraktionsmekanismer blir extra kraftfulla om de **kombineras**!

### Vad är en funktion?

En kaffekvarn! Som alla kaffekvarnar, har den nyckelordet def, och ett namn. Det finns också en parameterlucka där det står namnet på parametern samt vilken typ av indata som accepteras. Det finns också en resultatlucka.

1. Öppna parameterluckan
2. Stoppa in ett **argument**
3. Anropa funktioner/kaffekvarnen
4. Resultat returneras

### Om veckans tema: Funktioner

- Funktioner är en av de viktigaste abstraktionsmekanidmsernaninom datavetenskapen
- Du kan redan massornom funtioner, bl.a. från matematiken

### Funktion: Deklaration och anrop

`def funktionsnamn(parameterdeklarationen): returtyp = uttryck`

- En funktion har ett huvud och efter = kommer dess kropp
- En namngiven funktioj deklareras med nyckelordet def
- En funktion kan ha parametrar som deklareras i huvudet
- Kroppen ska vara ett utrryck
- Parametrar binds till argument vid anrop
- Uttrycket i fubktionens kropp evalueras vid varje anrop
- Värdet av uttrycket blir funktionen returvärde

### Deklarera funktioner, överlagring

- En parameter, sedan två parametrar
- Båda funktinoerna ovan kan finnas samtidigt! Trots att de har samma namn är de olika funktioner; kompilatorn kan skilja dem åt med hjälp av de olika parameterlistorna
- Detta kallas överlagring (overloading) av funktioner
- Överlagring ger flexibilitet i användningen; vi slipper hitta på nytt namn så som öka2 vid 2 parametrar.

### Funktioner med defaultargument

- Vi kan ofta åstadkomma samma flexibilitet som vid överlagring,k men med en enda funktion, om vi istället använder defaultargument

Exempel:

```scala

def inc(a: Int, b: Int = 1) = a + b

inc(42, 2) // 44
inc(42, 1) // 43
inc(42) // 43

```

### Funktioner med namngivna argument

- Genom att använda namngivna argument behöver man inte hålla reda på ordningen på parametrarna, bara man känner till parameternamnen.
- Namngivna argument går fint att kombinera med defaultargument.

```scala
def namn(förnamn: String,
         efternamn: String,
         förnamnFörst: Boolean = true,
         ledtext: String = "Namn: "): String = {

    if förnamnFörst then s"$ledtext $förnnamn $efternamn" else s"$ledtext $efternamn, $förnamn"
}

namn(ledtext = "Name: ", efternamn = "Coder", förnamn = "Kim")

```

### Enhetlig access

- Om en funktion deklareras med tom parameterlista () så ska den anropas med tom parameterlista

- En parameterlös funktion deklarerad utan () ska anropas utan ()

### Hur ser det ut i minnet när funktioner anropas?

#### Anropsstacken och objektheapen

Minnet som innehåller ett programs data är uppdelat i två delar:

- Anropsstacken:

  - På anropsstacken läggs en aktiversingspost (stack frame, activation recoird) för varje anrop med plkats för parametrar och lokala variablers
  - Aktiveringsposten raderas när returvärdet har levererats
  - Stacken växer vid nästlade funktionsanrop, då en funktion i sin tur anropade en annan funktion

- Objektheapen: I objektheapen sparas alla objekt som allokeras under körning. Heapen städas då och då av skräpsamlaren (garbage collector), och minne som inte används längre frigörs

### Aktiveringspost

Nästlade anrop ger växande anropsstack

```scala

def h(x: Int, y. Int) = { val z = x + y; println(z)}
def g(a: Int, b: Int) = { val x = 1; h(x + 1, a + b)}
def f() = { val n = 5; g(n, 2 * n)}
f()

```

### En funktion är ett **värde**

### Funktioner är äkta värden i Scala

- En fumktion är ett **äkta värde**
- Vi kan till exempel tilldela en variabel ett funktionsvärde
- Ett funktionsvärde har en typ precis som alla värden:
  `f: (Int, Int) => Int`
- Ett funktionsvärde har till skillnad från en funktionsdeklaration inget namn. Det kallas därför en anonym funktion eller lambda

### Funktionsvärden kan vara argument

En funktion som har en annan funktion som parameter:

```scala

def tvåGånger(x: Int, f: Int => Int) = f(f(x))
def öka(x: Int) = x + 1
def minska(x: Int) = x - 1

tvåGånger(42, öka) // 44
tvåGånger(42, minska) // 40

```

### Applicera funktioner på element i samlingar med map

```scala

def öka(x: Int) = x + 1
def minska(x: Int) = x - 1
val xs = Vector(1, 2, 3)


xs.map(öka) // Vector(2, 3, 4)
xs.map(minska) // Vector(0, 1, 2)

```
